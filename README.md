# Визуализация синтаксического анализа

## Введение
В данном проекте реализована наивная визуализация синтакцического анализа арифметического языка программирования с следующей грамматикой, ихображенной ниже.

    E' -> I
    I  -> id = E | E
    E  -> E + T | E - T | T
    T -> T * F | T / F | F
    F -> (E) | num | id

Работа вдохновлена книгой А. Ахо М. Лам Р. Сети Дж. Ульман "Компиляторы: принципы, технологии и инструментарий" и курсом "Тензорные компиляторы" от Сбера для студентов 2 курса ФРКТ МФТИ. Именно поэтому грамматика очень похожа на представленную в источниках.

Для получения потока токенов использовался *FLeX*.


## Принцип работы
Пример вывода программы для `id * id $` (программа всегда должна закачиваться знаком `$`,  который обозначение завершение программы):
```
_______________________________________________________________________________________________________
|              STACK              |              INPUT              |              ACTION             |
_______________________________________________________________________________________________________
|$                                |id * id $                        |                                 |
|$ ID_NUM                         |* id $                           |Shift                            |
|$ F                              |* id $                           |Reduce F -> id | num             |
|$ T                              |* id $                           |Reduce T -> F                    |
|$ T *                            |id $                             |Shift                            |
|$ T * ID_NUM                     |$                                |Shift                            |
|$ T * F                          |$                                |Reduce F -> id | num             |
|$ T                              |$                                |Reduce T -> T * F                |
|$ E                              |$                                |Reduce E -> T                    |
|$ I                              |$                                |Reduce I -> E                    |
|$ E'                             |$                                |Reduce E' -> I                   |
_______________________________________________________________________________________________________

```

Используется LR(0) анализ. Автомат этого анализа изображен на рис. 1. Как выполняется выбор *shift/reduce*? Рассматривается следующий токен из потока. Если имеется переход по этому токену, то делается *shift*, иначе *reduce*.

Сделаем этот алгоритм для `id * id`:
1) Так как переход от нетерминала `$` имеется по токену `id` делается *Shift*.
2) По токену `*` нет перехода нетерминала `ID_NUM`. *Reduce*
3) По токену `*` нет перехода нетерминала `F`. *Reduce*
4) По токену `*` есть переход нетерминала `T`. *Shift*
5) По токену `id` есть переход нетерминала `*`. *Shift*
6) INPUT пуст. *Reduce*
7) INPUT пуст. *Reduce*
8) INPUT пуст. *Reduce*
9) INPUT пуст. *Reduce*
10) INPUT пуст. *Reduce*

![Рис. 1](https://github.com/Artur99M/Images/blob/main/grammar.jpg)

## Запуск

В данной программе использовалась система сборки *CMake*. Для того, чтобы собрать программу вводим:
```
rm -rf build
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build
```
Файл *VSA.out* готов к работе в папке build.

## Тесты
Для создания тестов использовались *CTest*. Очень необычно, но тесты написаны на **C++**. Чтобы запустить тесты после сборки необходимо ввести:
```
cmake --build build --target test
```

Если хотите написать свои тесты, то добавьте в папку tests файл с расширением .dat и напишите туда текст, который необходимо распарсить. **Важно!** В тесты выводится как cout, так и cerr, который сигнализируется об ошибках.
