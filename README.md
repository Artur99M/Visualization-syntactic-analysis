# Визуализация синтаксического анализа

## Введение
В данном проекте реализована наивная визуализация синтакцического анализа арифметического языка программирования с следующей грамматикой, ихображенной ниже.

    E' -> I
    I  -> id = E | E
    E  -> E + T | E - T | T
    T -> T * F | T / F | F
    F -> (E) | num | id

Работа вдохновлена книгой А. Ахо М. Лам Р. Сети Дж. Ульман "Компиляторы: принципы, технологии и инструментарий" и курсом "Тензорные компиляторы" от Сбера для студентов 2 курса ФРКТ МФТИ. Именно поэтому грамматика очень похожа на представленную в источниках.

Для получения потока токенов использовался *FLeX*.


## Принцип работы
Пример вывода программы для `id * id $` (программа всегда должна закачиваться знаком `$`,  который обозначение завершение программы):
```
_______________________________________________________________________________________________________
|              STACK              |              INPUT              |              ACTION             |
_______________________________________________________________________________________________________
|                                 |id * id $                        |                                 |
|ID                               |* id $                           |Shift                            |
|ID_NUM                           |* id $                           |Reduce ID_NUM -> ID              |
|F                                |* id $                           |Reduce F -> id | num             |
|T                                |* id $                           |Reduce T -> F                    |
|T *                              |id $                             |Shift                            |
|T * ID                           |$                                |Shift                            |
|T * ID_NUM                       |$                                |Reduce ID_NUM -> ID              |
|T * F                            |$                                |Reduce F -> id | num             |
|T                                |$                                |Reduce T -> T * F | T / F        |
|E                                |$                                |Reduce E -> T                    |
|I                                |$                                |Reduce I -> E                    |
|E'                               |$                                |Reduce E' -> I                   |
_______________________________________________________________________________________________________

```

Используется LR(0) анализ. Автомат этого анализа изображен на рис. 1. Как выполняется выбор *shift/reduce*? Алгоритм представлен ниже.
1) Рассматривается следующий символ `a` из потока токенов. Если токены закончились и на вершине стека лежит нетерминал E', то выходим из цикла без предупреждения об ошибке, иначе переходим пункту 3.
2) Если можно выполнить *shift* для этого символа `a`, то выполняется переход и возвращаемся к первому пункту, иначе переходим к пункту 3.
3) Ищется самый длинный поток токенов, способный свернутся и сворачивается по правилам грамматики и сворачивается и возвращаемся к пункту 1. Если свернуться не удается, выдается ошибка.

Сделаем этот алгоритм для `id * id`:
1) На стеке пусто, просматриваем символ в потоке токенов. Можем перейти и переходим.
2) Для нетерминала на стеке нет перехода по символу `*`, делаем свертку.
3) Для нетерминала на стеке нет перехода по символу `*`, делаем свертку.
4) Для нетерминала `T` есть переход по токену `*`, делаем перенос.
5) Для пункта на стеке есть переход по токену `id`, делаем перенос.
6) Токены закончились, на вершине стека нет `E'`, делаем свертку.
7) Продукция матчится с нетерминалом `T`, делаем свертку.
8) Продукция матчится с нетерминалом `E`, делаем свертку.
9) Продукция матчится с нетерминалом `I`, делаем свертку.
10) Продукция матчится с нетерминалом `E'`, делаем свертку.
11) Токены закончились, на вершине стека лежит `E'`, выходим из цикла.


## Запуск

В данной программе использовалась система сборки *CMake*. Для того, чтобы собрать программу вводим:
```
rm -rf build
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build
```
Файл *VSA.out* готов к работе в папке build.

## Тесты
Для создания тестов использовались *CTest*. Очень необычно, но тесты написаны на **C++**. Чтобы запустить тесты после сборки необходимо ввести:
```
cmake --build build --target test
```

Если хотите написать свои тесты, то добавьте в папку tests файл с расширением .dat и напишите туда текст, который необходимо распарсить. **Важно!** В тесты выводится как cout, так и cerr, который сигнализируется об ошибках.
